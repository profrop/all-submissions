# -*- coding: utf-8 -*-
"""assignment 20 lecture(17-20) submission

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14JJqxtivOxxwoZimKInyn6N7U99rJsi5

In designing the HealthProfile class, I strictly followed the Single Responsibility Principle (SRP). The sole purpose of this class is to store and manage basic health data such as name, age, weight, height, gender, and activity level. It only includes logic related to computing health metrics, specifically BMI and BMR, which are derived directly from user data. This separation ensures that the class remains focused, simple, and reusable. Features such as workout tracking or calorie goals are deliberately excluded to avoid mixing concerns. This makes the system easier to maintain, test, and extend.
"""

#lecture 17: Health Profile Class

class HealthProfile:
    def __init__(self, name, age, weight_kg, height_cm, gender, activity_level):
        self.name = name
        self.age = age
        self.weight_kg = weight_kg
        self.height_cm = height_cm
        self.gender = gender.lower()
        self.activity_level = activity_level

    def get_bmi(self):
        height_m = self.height_cm / 100
        return round(self.weight_kg / (height_m ** 2), 2)

    def get_bmr(self):
        if self.gender == 'male':
            bmr = 10 * self.weight_kg + 6.25 * self.height_cm - 5 * self.age + 5
        elif self.gender == 'female':
            bmr = 10 * self.weight_kg + 6.25 * self.height_cm - 5 * self.age - 161
        else:
            raise ValueError("Gender must be 'male' or 'female'")
        return round(bmr, 2)

if __name__ == "__main__":
    user = HealthProfile(
        name="Lamech",
        age=20,
        weight_kg=58,
        height_cm=175,
        gender="male",
        activity_level="moderate"
    )

    print(f"Name: {user.name}")
    print(f"BMI: {user.get_bmi()}")
    print(f"BMR: {user.get_bmr()}")

"""This solution adheres to the Open/Closed Principle (OCP) by designing the CalorieCalculator system to be open for extension but closed for modification. The base class defines a common interface (calculate()), while each activity like Walking, Running, and Swimming is implemented in its own subclass with specific logic. To add a new activity we can create a new class without changing any existing code in the ActivityPlanner or other classes. The ActivityPlanner uses polymorphism to delegate the calculation to the correct activity class. This modular design makes the code maintainable and scalable ‚Äî we can extend functionality safely without risking bugs in existing logic. Thus, the system fully respects OCP principles."""

#Lecture 18: Extendable CalorieCalculator
# Base Class
class CalorieCalculator:
    def calculate(self, minutes):
        raise NotImplementedError("Subclasses must implement this method.")

# Subclass for Walking
class Walking(CalorieCalculator):
    def calculate(self, minutes):
        #calories burned = 4 * minutes
        return round(4 * minutes, 2)

# Subclass for Running
class Running(CalorieCalculator):
    def calculate(self, minutes):
        #calories burned = 10 * minutes
        return round(10 * minutes, 2)

# Subclass for Swimming
class Swimming(CalorieCalculator):
    def calculate(self, minutes):
        #calories burned = 8 * minutes
        return round(8 * minutes, 2)

# Activity Planner that uses polymorphism
class ActivityPlanner:
    def __init__(self):
        self.activities = {
            "walking": Walking(),
            "running": Running(),
            "swimming": Swimming()
        }

    def plan_activity(self, activity_name, minutes):
        activity = self.activities.get(activity_name.lower())
        if not activity:
            raise ValueError(f"Activity '{activity_name}' not supported.")
        return activity.calculate(minutes)

if __name__ == "__main__":
    planner = ActivityPlanner()

    activity = input("Enter activity (walking, running, swimming): ").strip().lower()
    minutes = int(input("Enter duration in minutes: "))

    try:
        calories = planner.plan_activity(activity, minutes)
        print(f"Calories burned during {minutes} minutes of {activity}: {calories}")
    except ValueError as e:
        print(e)

"""This design adheres to the Liskov Substitution Principle (LSP) by ensuring that each subclass (SmartWatch, SmartShoe, HeartRateBand) can be used anywhere a WorkoutDevice is expected, without causing runtime errors or needing special handling. Each device implements the required methods (start_tracking, stop_tracking, get_data) appropriately, maintaining consistent behavior. To honor the Interface Segregation Principle (ISP), I separated the heart rate feature into its own interface (HeartRateMonitor). This prevents devices like SmartShoe‚Äîwhich do not support heart rate‚Äîfrom being forced to implement unnecessary methods. Instead of returning errors or dummy data, unsupported functionality is simply not included in that class, and the test logic checks type safely using isinstance.This cleanly separates concerns and avoids bloated interfaces, ensuring both flexibility and robustness in adding or managing diverse devices."""

#Lecture 19: Workout Devices Simulation

from abc import ABC, abstractmethod

# Base interface for all workout devices
class WorkoutDevice(ABC):
    @abstractmethod
    def start_tracking(self):
        pass

    @abstractmethod
    def stop_tracking(self):
        pass

    @abstractmethod
    def get_data(self):
        """Returns a dictionary with time, steps, distance (and possibly heart_rate)"""
        pass


# Interface for devices that support heart rate
class HeartRateMonitor(ABC):
    @abstractmethod
    def get_heart_rate(self):
        pass


# Concrete class: SmartWatch
class SmartWatch(WorkoutDevice, HeartRateMonitor):
    def __init__(self):
        self.data = {"time": 0, "steps": 0, "distance": 0.0, "heart_rate": 75}
        self.tracking = False

    def start_tracking(self):
        self.tracking = True
        print("SmartWatch tracking started.")

    def stop_tracking(self):
        self.tracking = False
        print("SmartWatch tracking stopped.")

    def get_data(self):
        return self.data

    def get_heart_rate(self):
        return self.data["heart_rate"]


# Concrete class: SmartShoe
class SmartShoe(WorkoutDevice):
    def __init__(self):
        self.data = {"time": 0, "steps": 2000, "distance": 1.5}
        self.tracking = False

    def start_tracking(self):
        self.tracking = True
        print("SmartShoe tracking started.")

    def stop_tracking(self):
        self.tracking = False
        print("SmartShoe tracking stopped.")

    def get_data(self):
        return self.data


# Concrete class: HeartRateBand
class HeartRateBand(WorkoutDevice, HeartRateMonitor):
    def __init__(self):
        self.data = {"time": 0, "heart_rate": 80}
        self.tracking = False

    def start_tracking(self):
        self.tracking = True
        print("HeartRateBand tracking started.")

    def stop_tracking(self):
        self.tracking = False
        print("HeartRateBand tracking stopped.")

    def get_data(self):
        return self.data

    def get_heart_rate(self):
        return self.data["heart_rate"]


# Test function demonstrating polymorphism and substitution
def test_devices():
    devices = [SmartWatch(), SmartShoe(), HeartRateBand()]

    for device in devices:
        device.start_tracking()
        print("Data:", device.get_data())
        device.stop_tracking()

        # Heart rate check
        if isinstance(device, HeartRateMonitor):
            print("Heart Rate:", device.get_heart_rate())
        else:
            print("Heart Rate: Not supported on this device.")

        print("---")

if __name__ == "__main__":
    test_devices()

"""In this design, the planner CLI depends on the Workout abstraction, not concrete classes. Instead of hardcoding logic for Run, Walk, or Bike, the planner only requires that each subclass implements get_calories() and inherits from Workout. This follows the Dependency Inversion Principle (DIP): high-level modules (planner) do not depend on low-level modules (specific workout types). This makes the system extensible‚Äînew workouts (e.g., Swim, Yoga) can be added without changing the planner logic."""

#Lecture 20: Extend Fitness Tracker
#Part 1: Walk + Run + Bike Workouts

from datetime import datetime, timedelta
import json
import csv
import matplotlib.pyplot as plt


class Workout:
    def __init__(self, start, end, calories=None):
        self.start = start
        self.end = end
        self.calories = calories
        self.icon = 'üèãÔ∏è'
        self.kind = 'Generic'

    def get_duration(self):
        return self.end - self.start

    def get_calories(self):
        raise NotImplementedError("Subclasses must implement this method.")

    def __str__(self):
        return f"{self.icon} {self.kind} | Duration: {self.get_duration()} | Calories: {self.get_calories():.2f}"

    def __eq__(self, other):
        return (self.kind == other.kind) and (self.get_duration() == other.get_duration())


class RunWorkout(Workout):
    def __init__(self, start, end, distance_km, calories=None):
        super().__init__(start, end, calories)
        self.distance = distance_km
        self.icon = 'üèÉ‚Äç‚ôÇÔ∏è'
        self.kind = 'Running'

    def get_calories(self):
        # Approx: 60 kcal per km
        return self.distance * 60 if self.distance else self.get_duration().total_seconds() / 60 * 10


class WalkWorkout(Workout):
    def __init__(self, start, end, distance_km, calories=None):
        super().__init__(start, end, calories)
        self.distance = distance_km
        self.icon = 'üö∂‚Äç‚ôÇÔ∏è'
        self.kind = 'Walking'

    def get_calories(self):
        # Approx: 40 kcal per km
        return self.distance * 40 if self.distance else self.get_duration().total_seconds() / 60 * 4


class BikeWorkout(Workout):
    def __init__(self, start, end, distance_km, calories=None):
        super().__init__(start, end, calories)
        self.distance = distance_km
        self.icon = 'üö¥üèΩ‚Äç‚ôÇÔ∏è'
        self.kind = 'Cycling'

    def get_calories(self):
        # Approx: 300 kcal per hour cycling
        return self.get_duration().total_seconds() / 3600 * 300


#Part 2: Planner CLI

def create_workout(kind, start, end, distance=None):
    if kind.lower() == "bike":
        return BikeWorkout(start, end, distance)
    elif kind.lower() == "run":
        return RunWorkout(start, end, distance)
    elif kind.lower() == "walk":
        return WalkWorkout(start, end, distance)
    else:
        raise ValueError("Invalid workout type.")


def planner_cli():
    workouts = []
    while True:
        print("\n--- Workout Planner ---")
        kind = input("Choose workout type (Run/Walk/Bike) or 'quit': ")
        if kind.lower() == "quit":
            break

        start = datetime.fromisoformat(input("Enter start time (YYYY-MM-DD HH:MM): "))
        end = datetime.fromisoformat(input("Enter end time   (YYYY-MM-DD HH:MM): "))
        distance = float(input("Enter distance in km (optional, press Enter for 0): ") or 0)

        try:
            workout = create_workout(kind, start, end, distance)
            workouts.append(workout)
            print("Added:", workout)
        except Exception as e:
            print("Error:", e)

    return workouts

#Part 3: Extra Credit Features Implemented

def save_to_csv(workouts, filename="workouts.csv"):
    with open(filename, "w", newline="") as f:
        writer = csv.writer(f)
        writer.writerow(["Kind", "Start", "End", "Duration", "Calories"])
        for w in workouts:
            writer.writerow([w.kind, w.start, w.end, w.get_duration(), w.get_calories()])


def save_to_json(workouts, filename="workouts.json"):
    with open(filename, "w") as f:
        data = [
            {"kind": w.kind, "start": str(w.start), "end": str(w.end),
             "duration": str(w.get_duration()), "calories": w.get_calories()}
            for w in workouts
        ]
        json.dump(data, f, indent=4)


def plot_durations(workouts):
    kinds = [f"{w.icon} {w.kind}" for w in workouts]
    durations = [w.get_duration().total_seconds()/60 for w in workouts]  # minutes
    plt.bar(kinds, durations)
    plt.ylabel("Duration (minutes)")
    plt.title("Workout Durations")
    plt.show()

if __name__ == "__main__":
    all_workouts = planner_cli()
    save_to_csv(all_workouts, "workouts.csv")
    save_to_json(all_workouts, "workouts.json")
    plot_durations(all_workouts)

